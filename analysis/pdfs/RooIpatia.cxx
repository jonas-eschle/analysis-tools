/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// From https://github.com/gcowan/lhcb/blob/master/b2cc/analysis/phi_s/3fb/time_efficiency/LowerDecayTimeAcceptance/src/RooIpatia.cxx

#include "TMath.h"

#include "RooIpatia.h"
#include "RooIpatiaHelpers.h"


ClassImp(RooIpatia)

RooIpatia::RooIpatia(const char *name, const char *title,
                       RooAbsReal& _x,
                       RooAbsReal& _l,
                       RooAbsReal& _zeta,
                       RooAbsReal& _fb,
                       RooAbsReal& _sigma,
                       RooAbsReal& _mu,
                       RooAbsReal& _a,
                       RooAbsReal& _n) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  l("l","l",this,_l),
  zeta("zeta","zeta",this,_zeta),
  fb("fb","fb",this,_fb),
  sigma("sigma","sigma",this,_sigma),
  mu("mu","mu",this,_mu),
  a("a","a",this,_a),
  n("n","n",this,_n)
{
}


RooIpatia::RooIpatia(const RooIpatia& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  l("l",this,other.l),
  zeta("zeta",this,other.zeta),
  fb("fb",this,other.fb),
  sigma("sigma",this,other.sigma),
  mu("mu",this,other.mu),
  a("a",this,other.a),
  n("n",this,other.n)
{
}



Double_t RooIpatia::evaluate() const
{
  Double_t d = x-mu;
  Double_t cons0 = sqrt(zeta);
  Double_t alpha, beta, delta,  cons1, phi, A, B, k1, k2;
  Double_t asigma = a*sigma;
  Double_t out = 0.0;
  if (zeta!= 0.) {
    phi = BK(l+1,zeta)/BK(l,zeta); // careful if zeta -> 0. You can implement a function for the ratio, but carefull again that |nu + 1 | != |nu| + 1 so you jave to deal wiht the signs
    cons1 = sigma/sqrt(phi);
    alpha  = cons0/cons1;//*sqrt((1 - fb*fb));
    beta = fb;//*alpha;
    //gamma = sqrt(alpha*alpha - beta*beta);
    delta = cons0*cons1;
    //printf("%e\n",phi);
    //printf("%e\n",cons0);
    //printf("%e\n",cons1);
    //printf("%e\n",exp(beta*d));
    //printf("%e\n",alpha);
    //printf("%e\n",delta);
    //printf("%e\n",LogEval(x,l,alpha,beta,delta, mu));

    if (d > -asigma ) return LogEval(d,l,alpha,beta,delta);
    k1 = LogEval(-asigma,l,alpha,beta,delta);
    k2 = diff_eval(-asigma,l,alpha,beta,delta);
    B = -asigma + n*k1/k2;
    A = k1*pow(B+asigma,n);
    out =  A*pow(B-d,-n);

    //return LogEval(x,l,alpha,beta,delta, mu);

  }
  else if (l < 0) {
    beta = fb;
    cons1 = -2*l;
    delta = sigma;
    if (d > -asigma ) return  exp(beta*d)*pow(1 + d*d/(delta*delta),l-0.5);
    cons1 = exp(-beta*asigma);
    phi = 1 + a*a;
    k1 = cons1*pow(phi,l-0.5);
    k2 = beta*k1- cons1*(l-0.5)*pow(phi,l-1.5)*2*a/delta;
    B = -asigma + n*k1/k2;
    A = k1*pow(B+asigma,n);
    out = A*pow(B-d,-n);

  }

  return out;

}

